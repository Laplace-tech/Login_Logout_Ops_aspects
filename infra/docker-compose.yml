services:

  # [services.mysql]: 로컬 개발용 DB
  # - 로컬 개발 실행용 DB, 테스트(Testcontainers)와 완전히 분리됨
  # - 테스트는 AbstractIntegrationTest 안의 MySQLContainer(테스트 전용 컨테이너)를 띄워서 씀.
  # - 그래서 "로컬 실행은 compose mysql", "테스트는 testcontainers mysql" 이렇게 이원화된다.
  mysql:
    image: mysql:8.0
    container_name: kyonggi-mysql
    command:
      - --default-authentication-plugin=mysql_native_password
      - --character-set-server=utf8mb4
      - --collation-server=utf8mb4_0900_ai_ci
    environment:
      MYSQL_ROOT_PASSWORD: root     # 컨테이너 첫 기동 시 "루트 계정 비밀번호" 설정
      MYSQL_DATABASE: kyonggi_board # 컨테이너 첫 기동 시 "기본 DB 생성"
      MYSQL_USER: kyonggi           # 컨테이너 첫 기동 시 "일반 유저 생성"
      MYSQL_PASSWORD: kyonggi
      TZ: Asia/Seoul                # MySQL 내부 시간대 (로그/타임존 관련)

    ports:
      - "127.0.0.1:3306:3306" # "호스트(내 PC) 127.0.0.1:3306" -> "컨테이너 3306" 바인딩

    volumes:
      - mysql_data:/var/lib/mysql # mysql_data 라는 named volume에 /var/lib/mysql을 저장 (컨테이너를 내려도 DB 데이터가 유지됨)
      - ./mysql-init:/docker-entrypoint-initdb.d

    healthcheck:
      # MySQL이 "진짜로 준비 완료" 상태인지 검사.
      # 단순히 컨테이너가 떴다고 DB가 바로 쓸 수 있는게 아니라,
      # 내부 초기화 시간이 걸리므로 이게 중요함.
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-proot"]

      interval: 5s # 5초마다 체크
      timeout: 3s  # 체크 명령 최대 3초 기다림
      retries: 30  # 최대 30번 재시도 (대략 150초까지 허용 가능)
      start_period: 20s # 컨테이너 시작 후 20초는 실패해도 봐준다(부팅 워밍업 기간)


  # [services.mailhog]: 로컬 SMTP 캡처 서버
  # - 회원가입 OTP 메일을 "진짜 SMTP로 전송"하되, 외부 메일 서버(Gmail 등) 없이 로컬에서 메일을 캡처해서 UI로 확인 가능.
  # - 테스트에서는 이 MailHog를 사용하지 않고, Testcontainers로 별도의 MailHog 컨테이너를 띄워서 테스트 격리.
  # - UI 접속: http://localhost:8025
  mailhog:
    image: mailhog/mailhog:v1.0.1
    container_name: kyonggi-mailhog
    ports:
      # 1025 = SMTP 포트(스프링이 여기에 메일 전송)
      - "1025:1025"
      # 8025 = 웹 UI 포트(브라우저로 받은 메일 확인)
      - "8025:8025"


  # [services.backend]
  # - Spring 실행 시 활성 프로파일 지정 (SPRING_PROFILES_ACTIVE)
  backend:
    build:
      context: ../backend    # ../backend 폴더를 빌드 컨텍스트로 사용
      dockerfile: Dockerfile # 그 안의 Dockerfile로 이미지를 만든다

    container_name: kyonggi-backend

    ports:
      # 호스트 8080 -> 컨테이너 8080
      # 즉 브라우저/curl에서 http://localhost:8080 으로 백엔드 접근 가능
      - "8080:8080"

    restart: on-failure # 비정상 종료 시 재시작 (DB 준비시간/일시적 실패 대비)

    environment:
      SPRING_PROFILES_ACTIVE: local  # Spring이 local 프로파일로 뜨게 함

      # [DB 연결]
      # 여기서 jdbc:mysql://mysql:3306/... 의 mysql 은 "서비스 이름"이다.
      # docker-compose 네트워크 안에서는:
      # - backend 컨테이너가 mysql 컨테이너를 "mysql"이라는 호스트명으로 찾는다.
      #
      # - 내 PC에서 DB 접속: localhost:3306 (ports로 열어줬기 때문)
      # - backend 컨테이너에서 DB 접속: mysql:3306 (compose 내부 DNS)
      SPRING_DATASOURCE_URL: jdbc:mysql://mysql:3306/kyonggi_board?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=Asia/Seoul&characterEncoding=utf8
      SPRING_DATASOURCE_USERNAME: kyonggi
      SPRING_DATASOURCE_PASSWORD: kyonggi

      # [메일 연결]
      # mailhog 서비스로 SMTP 전송 (스프링이 SMTP 포트 1025를 향해 전송)
      SPRING_MAIL_HOST: mailhog
      SPRING_MAIL_PORT: 1025

      # [비밀 키 주입] (.env에서 가져옴)
      # APP_AUTH_JWT_SECRET / APP_OTP_HMAC_SECRET 은
      # infra/.env 파일에 있는 값을 compose가 읽어서 여기로 주입한다.
      #
      # ${...:?set in infra/.env} 의미:
      # - 해당 환경변수가 없으면 에러로 compose 실행을 실패시켜라(강제).
      # - 즉 "키 안 넣고 실행해서 JWT/OTP가 비정상 동작" 같은 사고를 초기에 차단.
      APP_AUTH_JWT_SECRET: ${APP_AUTH_JWT_SECRET:?set in infra/.env}
      APP_OTP_HMAC_SECRET: ${APP_OTP_HMAC_SECRET:?set in infra/.env}

      # [Flyway 연결 재시도]
      # 앱 시작 시 Flyway가 DB에 붙어서 마이그레이션을 수행하는데,
      # DB가 아직 기동 중이면 연결 실패가 날 수 있음.
      # 그래서 재시도를 걸어두는 안전장치.
      SPRING_FLYWAY_CONNECT_RETRIES: 30
      SPRING_FLYWAY_CONNECT_RETRIES_INTERVAL: 2

    depends_on:
      mysql:
        condition: service_healthy # backend는 mysql이 "healthy" 될 때까지 기다린 다음에 시작
      mailhog:
        condition: service_started # mailhog는 뜨기만 하면 OK 

volumes:
  # mysql_data는 "도커가 관리하는 데이터 저장소"
  # 컨테이너를 삭제/재생성해도 데이터가 유지되어 개발이 편해짐.
  mysql_data:
